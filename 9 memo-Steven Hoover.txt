Because it accurately depicts the fundamental idea of the system—a web of interconnected entities—a graph is the best data structure for this social network.  The many-to-many, non-linear relationships that characterize a social fabric are ideally represented by each friendship as a bidirectional edge and each individual as a node (or vertex).   This work is not well suited for alternative structures.  For instance, a simple list would be quite inefficient; as lists lack an intrinsic relational mapping, it may be necessary to iterate through the entire dataset in order to find a person or their connections. A tree is fundamentally incompatible, as it imposes a rigid, hierarchical parent-child structure and, crucially, forbids the cyclical relationships (e.g., A is friends with B, B with C, and C with A) that are a hallmark of all real-world social networks.

In terms of performance, my implementation makes a critical and effective structural trade-off by using a dictionary (self.people) to map string names to Person objects. This provides O(1) average-time complexity for looking up any person, which in turn makes the add_friendship operation extremely fast—it's essentially two O(1) lookups followed by two list appends. The trade-off for this lookup speed is a slightly higher memory footprint to maintain the hash map versus a simple list. For the print_network function, the performance is necessarily tied to the network's size. It must perform an O(N + E) traversal, where N is the number of people (nodes) and E is the total number of friendships (edges), as it must visit every person and then iterate through each of their friends' lists to display the complete structure. This is an efficient and standard performance characteristic for full graph traversal.